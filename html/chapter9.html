<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 9: 高级点云算法</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">激光雷达完整技术教程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1: 激光雷达基础原理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2: 激光雷达技术发展与主要厂商</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3: 激光雷达类型与扫描机制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4: 激光雷达制造技术</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5: 信号处理与时序控制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6: 误差源分析（非信号处理）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7: 激光雷达独特优势与性能极限</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8: 点云处理基础算法</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9: 高级点云算法</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 10: 标定技术</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11: 多传感器融合算法</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12: 自动驾驶专用章节</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 13: 机器人应用（人形与仓储）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 14: 其他应用领域</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">激光雷达教程项目说明</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-9">Chapter 9: 高级点云算法</h1>
<p>本章深入探讨激光雷达点云处理的高级算法，包括点云配准、SLAM（同时定位与地图构建）和目标检测。这些算法是实现自动驾驶、机器人导航和三维重建等应用的关键技术。我们将详细介绍每种算法的数学原理、实现细节和性能优化方法。</p>
<h2 id="91">9.1 点云配准</h2>
<p>点云配准是将不同时刻或不同视角获取的点云数据对齐到同一坐标系的过程。这是多帧点云融合、SLAM和目标跟踪的基础。在实际应用中，配准精度直接影响地图质量和定位精度。</p>
<h3 id="911-icp">9.1.1 ICP算法原理</h3>
<p>迭代最近点（Iterative Closest Point, ICP）算法是最经典的点云配准方法。给定源点云P = {p₁, p₂, ..., pₙ}和目标点云Q = {q₁, q₂, ..., qₘ}，ICP通过迭代优化找到最优的旋转矩阵R和平移向量t。</p>
<p><strong>数学基础：</strong></p>
<p>刚体变换的李群表示：</p>
<div class="codehilite"><pre><span></span><code><span class="n">T</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="n">SE</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">R</span><span class="w">  </span><span class="n">t</span><span class="p">]</span>
<span class="w">                </span><span class="p">[</span><span class="mi">0</span><span class="w">  </span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>

<p>其中R ∈ SO(3)满足RᴿR = I, det(R) = 1。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><strong>最近点匹配</strong>：对源点云中每个点pᵢ，在目标点云中找到最近点qⱼ</li>
</ol>
<div class="codehilite"><pre><span></span><code>j = argmin‖qₖ - Rpᵢ - t‖²
     k
</code></pre></div>

<p>使用KD-tree加速，查询复杂度O(log m)。</p>
<ol start="2">
<li><strong>计算变换</strong>：最小化误差函数</li>
</ol>
<div class="codehilite"><pre><span></span><code>E(R,t) = Σᵢ₌₁ⁿ wᵢ‖qᵢ&#39; - (Rpᵢ + t)‖²
</code></pre></div>

<p>其中qᵢ'是pᵢ的对应点，wᵢ是权重（通常基于距离或法向量一致性）。</p>
<ol start="3">
<li><strong>质心计算</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>p̄ = (Σᵢwᵢpᵢ)/(Σᵢwᵢ)
q̄ = (Σᵢwᵢqᵢ&#39;)/(Σᵢwᵢ)
</code></pre></div>

<ol start="4">
<li><strong>协方差矩阵</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>H = Σᵢwᵢ(pᵢ - p̄)(qᵢ&#39; - q̄)ᵀ
</code></pre></div>

<ol start="5">
<li><strong>SVD分解求解旋转</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>H = UΣVᵀ
R = V·diag(1,1,det(VUᵀ))·Uᵀ
</code></pre></div>

<p>注意：需要检查det(VUᵀ)确保得到旋转而非反射。</p>
<ol start="6">
<li><strong>计算平移</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>t = q̄ - Rp̄
</code></pre></div>

<p><strong>详细计算实例：</strong></p>
<p>假设有3D点云配准问题：</p>
<ul>
<li>源点云：P = {(1,0,0), (0,1,0), (0,0,1), (1,1,0)}</li>
<li>目标点云：Q为P绕z轴旋转30°并平移(0.5, 0.5, 0)</li>
</ul>
<p>第一次迭代：</p>
<p>步骤1：计算质心</p>
<div class="codehilite"><pre><span></span><code>p̄ = (1/4)[(1,0,0) + (0,1,0) + (0,0,1) + (1,1,0)]
  = (0.5, 0.5, 0.25)

对应点通过最近邻搜索获得：
q₁&#39; = (0.866, 0.5, 0)    // (1,0,0)旋转30°
q₂&#39; = (-0.5, 0.866, 0)   // (0,1,0)旋转30°
q₃&#39; = (0, 0, 1)          // (0,0,1)不变
q₄&#39; = (0.366, 1.366, 0)  // (1,1,0)旋转30°

q̄ = (0.183, 0.683, 0.25)
</code></pre></div>

<p>步骤2：构建H矩阵</p>
<div class="codehilite"><pre><span></span><code>H = Σᵢ(pᵢ - p̄)(qᵢ&#39; - q̄)ᵀ

计算去中心化坐标：
p₁&#39; = (0.5, -0.5, -0.25)
q₁&#39; = (0.683, -0.183, -0.25)

H累加所有对应点对的贡献...
</code></pre></div>

<p>步骤3：SVD分解</p>
<div class="codehilite"><pre><span></span><code>H = UΣVᵀ
其中U、V是正交矩阵，Σ是对角矩阵

R = VUᵀ ≈ [0.866  -0.5    0  ]
          [0.5     0.866  0  ]
          [0       0      1  ]
</code></pre></div>

<p>步骤4：计算平移</p>
<div class="codehilite"><pre><span></span><code>t = q̄ - Rp̄ ≈ (0.5, 0.5, 0)
</code></pre></div>

<p><strong>收敛判定：</strong></p>
<div class="codehilite"><pre><span></span><code>ΔE = |Eₖ - Eₖ₋₁| &lt; ε_E  或  ‖Rₖ - Rₖ₋₁‖_F &lt; ε_R
</code></pre></div>

<p>典型阈值：ε_E = 10⁻⁶, ε_R = 10⁻⁴</p>
<h3 id="912">9.1.2 收敛性分析</h3>
<p>ICP算法的收敛性依赖于初始配准精度。设初始旋转误差为θ₀，平移误差为d₀，则：</p>
<p><strong>收敛域分析</strong>：</p>
<p>根据Besl和McKay的理论分析，ICP的收敛域可表示为：</p>
<div class="codehilite"><pre><span></span><code>C = {(R₀,t₀) | ‖log(R₀ᵀR_true)‖ &lt; θ_max, ‖t₀ - t_true‖ &lt; d_max}
</code></pre></div>

<p>其中：</p>
<ul>
<li>θ_max ≈ π/6 (30°) 对于大多数场景</li>
<li>d_max ≈ 0.3 × min(点云直径)</li>
</ul>
<p><strong>收敛速度分析</strong>：</p>
<p>误差的迭代更新模型：</p>
<div class="codehilite"><pre><span></span><code>εₖ₊₁ = ρ(εₖ) · εₖ + O(εₖ²)
</code></pre></div>

<p>其中收敛因子ρ依赖于：</p>
<ol>
<li><strong>点云重叠率η</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>ρ ≈ 1 - η + 0.5η²
</code></pre></div>

<p>当η &gt; 0.5时，ρ &lt; 0.625，保证快速收敛。</p>
<ol start="2">
<li><strong>噪声水平σ</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>ρ_noise = ρ_ideal · (1 + 2σ²/d_avg²)
</code></pre></div>

<p>其中d_avg是平均点间距。</p>
<ol start="3">
<li><strong>采样密度</strong>：
   密度越高，收敛越快。经验公式：</li>
</ol>
<div class="codehilite"><pre><span></span><code>iterations ≈ -log(ε_target/ε₀) / log(ρ)
</code></pre></div>

<p><strong>计算实例：</strong></p>
<p>设初始误差：θ₀ = 20°, d₀ = 1m
点云参数：直径10m，重叠率70%，噪声σ = 2cm</p>
<p>收敛因子计算：</p>
<div class="codehilite"><pre><span></span><code>ρ_ideal = 1 - 0.7 + 0.5×0.7² = 0.545
ρ_noise = 0.545 × (1 + 2×0.02²/0.1²) = 0.589
</code></pre></div>

<p>达到1mm精度需要的迭代次数：</p>
<div class="codehilite"><pre><span></span><code>n = -log(0.001/1) / log(0.589) ≈ 13次
</code></pre></div>

<p><strong>局部最优问题及解决方案</strong>：</p>
<ol>
<li><strong>对称性导致的歧义</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>检测方法：计算Hessian矩阵的条件数
κ(H) = λ_max/λ_min &gt; 1000 表示存在歧义
</code></pre></div>

<ol start="2">
<li><strong>多初始值策略</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>初始旋转集合：{R₀, R_z(90°)R₀, R_z(180°)R₀, R_z(270°)R₀}
选择误差最小的结果
</code></pre></div>

<ol start="3">
<li><strong>鲁棒损失函数</strong>：
   Huber损失：</li>
</ol>
<div class="codehilite"><pre><span></span><code>ρ(e) = {e²/2,           |e| ≤ δ
       {δ(|e| - δ/2),  |e| &gt; δ
</code></pre></div>

<p>其中δ = 1.345σ（95%效率）</p>
<ol start="4">
<li><strong>特征增强ICP</strong>：
   加入曲率、法向量、颜色等特征：</li>
</ol>
<div class="codehilite"><pre><span></span><code>d_total = d_geometric + α·d_feature
</code></pre></div>

<p>典型α = 0.1-0.3</p>
<h3 id="913-ndt">9.1.3 NDT配准算法</h3>
<p>正态分布变换（Normal Distributions Transform, NDT）将点云空间划分为规则格子，每个格子内的点用高斯分布表示。这种表示方法将离散点云转换为连续概率场，使优化过程更加平滑。</p>
<p><strong>理论基础</strong>：</p>
<p>NDT假设每个格子内的点服从三维正态分布：</p>
<div class="codehilite"><pre><span></span><code>p(x) = 1/((2π)^(3/2)|Σ|^(1/2)) exp(-1/2(x-μ)ᵀΣ⁻¹(x-μ))
</code></pre></div>

<p>为了数值稳定性，使用正则化协方差：</p>
<div class="codehilite"><pre><span></span><code><span class="err">Σ</span><span class="n">_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">Σ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">ε</span><span class="n">I</span>
</code></pre></div>

<p>其中ε = 0.01×格子大小²。</p>
<p><strong>格子划分策略</strong>：</p>
<ol>
<li><strong>自适应格子大小</strong>：
   根据点云密度动态调整：</li>
</ol>
<div class="codehilite"><pre><span></span><code>r = k × (V/n)^(1/3)
</code></pre></div>

<p>其中V是点云体积，n是点数，k ≈ 10。</p>
<ol start="2">
<li><strong>八叉树划分</strong>：
   对稀疏区域使用大格子，密集区域细分：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="ss">(</span>点数<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nv">threshold</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">subdivide</span><span class="ss">()</span>
}
</code></pre></div>

<p><strong>优化目标函数</strong>：</p>
<p>负对数似然：</p>
<div class="codehilite"><pre><span></span><code>f(p) = -Σᵢ₌₁ⁿ log(Σₖ∈Nᵢ αₖ·pₖ(T(pᵢ)))
</code></pre></div>

<p>简化为得分函数：</p>
<div class="codehilite"><pre><span></span><code>score(p) = Σᵢ₌₁ⁿ exp(-1/2 dᵢᵀΣᵢ⁻¹dᵢ)
</code></pre></div>

<p>其中dᵢ = T(pᵢ) - μᵢ。</p>
<p><strong>梯度和Hessian计算</strong>：</p>
<p>对于变换参数p = [tx, ty, tz, φ, θ, ψ]ᵀ：</p>
<ol>
<li><strong>一阶导数</strong>（得分梯度）：</li>
</ol>
<div class="codehilite"><pre><span></span><code>g = ∂score/∂p = Σᵢ exp(-qᵢ/2) · Σᵢ⁻¹ · dᵢ · ∂T(pᵢ)/∂p
</code></pre></div>

<p>其中qᵢ = dᵢᵀΣᵢ⁻¹dᵢ。</p>
<ol start="2">
<li><strong>二阶导数</strong>（Hessian矩阵）：</li>
</ol>
<div class="codehilite"><pre><span></span><code>H = -Σᵢ exp(-qᵢ/2)[JᵢᵀΣᵢ⁻¹Jᵢ - 1/2(JᵢᵀΣᵢ⁻¹dᵢ)(dᵢᵀΣᵢ⁻¹Jᵢ)]
</code></pre></div>

<p>其中Jᵢ = ∂T(pᵢ)/∂p是雅可比矩阵。</p>
<p><strong>雅可比矩阵详细形式</strong>：</p>
<p>对于点p = [x, y, z]ᵀ和欧拉角参数化：</p>
<div class="codehilite"><pre><span></span><code>J = [1  0  0  -y·cψ-z·sψsφ    z·cψcφ     -x·sψ+y·cψsθ+z·sψcθsφ]
    [0  1  0   y·sψ-z·cψsφ    z·sψcφ      x·cψ+y·sψsθ+z·cψcθsφ]
    [0  0  1   z·cφ           -z·sφsθ-y·cθ  0                    ]
</code></pre></div>

<p><strong>牛顿法优化步骤</strong>：</p>
<ol>
<li>计算当前变换下的得分、梯度和Hessian</li>
<li>求解线性系统：H·Δp = -g</li>
<li>线搜索确定步长α：</li>
</ol>
<div class="codehilite"><pre><span></span><code>p_new = p + α·Δp
α = argmax score(p + α·Δp)
</code></pre></div>

<ol start="4">
<li>更新参数并检查收敛</li>
</ol>
<p><strong>计算实例</strong>：</p>
<p>设置场景参数：</p>
<ul>
<li>点云范围：50m×50m×10m</li>
<li>格子大小：1m</li>
<li>点云数量：10000点</li>
<li>目标精度：1cm</li>
</ul>
<p>步骤1：格子化</p>
<div class="codehilite"><pre><span></span><code>格子数：50×50×10 = 25000
平均每格子点数：0.4
有效格子（&gt;5点）：约2000个
</code></pre></div>

<p>步骤2：计算正态分布参数
对格子(i,j,k)内的m个点：</p>
<div class="codehilite"><pre><span></span><code>μ = [25.3, 12.7, 1.5]ᵀ
Σ = [0.12  0.02  0.01]
    [0.02  0.15  0.02]
    [0.01  0.02  0.08]
</code></pre></div>

<p>步骤3：优化迭代</p>
<div class="codehilite"><pre><span></span><code><span class="err">迭代</span><span class="mi">0</span><span class="o">:</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">5834.2</span><span class="o">,</span><span class="w"> </span><span class="o">|</span><span class="n">g</span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">125.3</span>
<span class="err">迭代</span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">2156.7</span><span class="o">,</span><span class="w"> </span><span class="o">|</span><span class="n">g</span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">45.2</span>
<span class="err">迭代</span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">892.3</span><span class="o">,</span><span class="w">  </span><span class="o">|</span><span class="n">g</span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">12.8</span>
<span class="o">...</span>
<span class="err">迭代</span><span class="mi">8</span><span class="o">:</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">125.6</span><span class="o">,</span><span class="w">  </span><span class="o">|</span><span class="n">g</span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.9</span>
<span class="err">收敛！最终误差</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="n">cm</span>
</code></pre></div>

<p><strong>性能优化技巧</strong>：</p>
<ol>
<li>
<p><strong>GPU加速</strong>：
   - 并行计算每个点的贡献
   - 使用texture memory存储格子参数
   - 加速比：10-20倍</p>
</li>
<li>
<p><strong>多分辨率策略</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code>Level 1: 格子4m, 迭代5次
Level 2: 格子2m, 迭代5次
Level 3: 格子1m, 迭代10次
</code></pre></div>

<ol start="3">
<li><strong>稀疏矩阵优化</strong>：
   只计算非零格子的贡献，减少90%计算量。</li>
</ol>
<p><strong>NDT vs ICP对比实验</strong>：</p>
<p>测试条件：</p>
<ul>
<li>Intel i7 CPU, 16GB RAM</li>
<li>点云大小：50000点</li>
<li>初始误差：15°旋转，2m平移</li>
</ul>
<p>结果：</p>
<div class="codehilite"><pre><span></span><code>算法   精度(cm)  时间(ms)  迭代次数
ICP    0.8       125       35
NDT    1.2       42        12
NDT-GPU 1.2      8         12
</code></pre></div>

<h3 id="914">9.1.4 配准误差评估</h3>
<p>配准质量评估是确保算法可靠性的关键步骤。需要从多个维度评估配准结果。</p>
<p><strong>误差度量方法</strong>：</p>
<ol>
<li><strong>点到点误差（P2P）</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>RMSE_p2p = √((1/n)Σᵢ₌₁ⁿ ‖Rpᵢ + t - qᵢ&#39;‖²)
</code></pre></div>

<p>优点：计算简单，直观
   缺点：对噪声敏感，依赖对应关系</p>
<ol start="2">
<li><strong>点到面误差（P2Plane）</strong>：
   考虑目标点云的局部平面结构：</li>
</ol>
<div class="codehilite"><pre><span></span><code>E_p2plane = √((1/n)Σᵢ₌₁ⁿ (nᵢᵀ(Rpᵢ + t - qᵢ&#39;))²)
</code></pre></div>

<p>其中nᵢ是qᵢ'处的法向量，通过PCA计算：
   <code>C = Σⱼ∈N(qᵢ')(qⱼ - q̄)(qⱼ - q̄)ᵀ
   nᵢ = 最小特征值对应的特征向量</code></p>
<ol start="3">
<li><strong>平面到平面误差（Plane2Plane）</strong>：
   对于结构化环境特别有效：</li>
</ol>
<div class="codehilite"><pre><span></span><code>E_plane = Σₖ₌₁ᴷ wₖ · ‖nₖ^s - Rnₖ^t‖² + λ|dₖ^s - dₖ^t|²
</code></pre></div>

<p>其中nₖ是平面法向量，dₖ是到原点距离。</p>
<p><strong>不确定度估计</strong>：</p>
<p>配准的不确定度可通过信息矩阵估计：</p>
<ol>
<li><strong>信息矩阵构建</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>I = Σᵢ₌₁ⁿ JᵢᵀWᵢJᵢ
</code></pre></div>

<p>其中：</p>
<ul>
<li>Jᵢ：第i个点对的雅可比矩阵（6×3）</li>
<li>Wᵢ：权重矩阵，通常为Σᵢ⁻¹</li>
</ul>
<ol start="2">
<li><strong>协方差矩阵</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>Cov = I⁻¹ = (JᵀWJ)⁻¹
</code></pre></div>

<p>对角元素表示各参数的方差：
   <code>σ²_tx, σ²_ty, σ²_tz, σ²_roll, σ²_pitch, σ²_yaw</code></p>
<ol start="3">
<li><strong>置信椭球</strong>：
   95%置信区间：</li>
</ol>
<div class="codehilite"><pre><span></span><code>(x - μ)ᵀCov⁻¹(x - μ) ≤ χ²₆(0.95) = 12.59
</code></pre></div>

<p><strong>计算实例：</strong></p>
<p>假设配准了两帧激光雷达数据，1000个匹配点对：</p>
<p>误差统计：</p>
<div class="codehilite"><pre><span></span><code><span class="err">点到点</span><span class="n">RMSE</span><span class="o">:</span><span class="w"> </span><span class="mf">0.025</span><span class="n">m</span>
<span class="err">点到面</span><span class="n">RMSE</span><span class="o">:</span><span class="w"> </span><span class="mf">0.018</span><span class="n">m</span>

<span class="err">协方差矩阵（简化）：</span>
<span class="n">Cov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="mf">0.0001</span><span class="w">   </span><span class="mi">0</span><span class="w">        </span><span class="mi">0</span><span class="w">     </span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="n">m²</span><span class="o">)</span>
<span class="w">      </span><span class="o">[</span><span class="mi">0</span><span class="w">        </span><span class="mf">0.0001</span><span class="w">   </span><span class="mi">0</span><span class="w">     </span><span class="o">]</span>
<span class="w">      </span><span class="o">[</span><span class="mi">0</span><span class="w">        </span><span class="mi">0</span><span class="w">        </span><span class="mf">0.0002</span><span class="o">]</span>

<span class="err">位置不确定度：</span>
<span class="err">σ</span><span class="n">_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">σ</span><span class="n">_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="n">cm</span><span class="o">,</span><span class="w"> </span><span class="err">σ</span><span class="n">_z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.4</span><span class="n">cm</span>
</code></pre></div>

<p><strong>配准质量指标</strong>：</p>
<ol>
<li><strong>适合度（Fitness Score）</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>fitness = (1/n_inlier) Σ_inliers d²ᵢ
</code></pre></div>

<p>典型阈值：fitness &lt; 0.05m</p>
<ol start="2">
<li><strong>内点率（Inlier Ratio）</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>ratio = n_inlier / n_total
</code></pre></div>

<p>好的配准：ratio &gt; 0.8</p>
<ol start="3">
<li><strong>重叠率估计</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>overlap = |P ∩ Q| / min(|P|, |Q|)
</code></pre></div>

<p>使用体素化快速估计。</p>
<h3 id="915">9.1.5 鲁棒配准方法</h3>
<p>实际点云常包含噪声、离群点和部分重叠，需要鲁棒的配准策略。</p>
<p><strong>RANSAC-ICP算法</strong>：</p>
<p>结合RANSAC的鲁棒性和ICP的精确性：</p>
<ol>
<li>
<p><strong>最小采样集确定</strong>：
   - 3D刚体变换：最少需要3个非共线点
   - 考虑退化情况，实际采样4-5个点</p>
</li>
<li>
<p><strong>算法流程</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code>for iter = 1 to N:
    // 随机采样
    sample = random_select(P, 4)

    // 计算初始变换
    (R₀, t₀) = solve_transform(sample, Q)

    // 评估内点
    inliers = {p | min_q‖R₀p + t₀ - q‖ &lt; threshold}

    if |inliers| &gt; best_inliers:
        // 使用所有内点精炼
        (R, t) = ICP(inliers, Q)
        best_transform = (R, t)
</code></pre></div>

<ol start="3">
<li><strong>迭代次数计算</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>N = log(1 - p) / log(1 - w^m)
</code></pre></div>

<p>实例：p=0.99, w=0.5（50%内点）, m=4
   <code>N = log(0.01) / log(1 - 0.5⁴) = 72次</code></p>
<p><strong>Trimmed ICP（TrICP）</strong>：</p>
<p>只使用最近的k%点对进行配准：</p>
<ol>
<li><strong>重叠率自适应</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>k = estimated_overlap × safety_factor
</code></pre></div>

<p>其中safety_factor ≈ 0.8-0.9。</p>
<ol start="2">
<li><strong>迭代修剪</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>每次迭代：

1. 计算所有点对距离
2. 排序并选择最小的k%
3. 仅用这k%计算变换
</code></pre></div>

<ol start="3">
<li><strong>性能分析</strong>：
   - 鲁棒性：可处理高达(100-k)%的离群点
   - 计算开销：增加O(n log n)的排序时间</li>
</ol>
<p><strong>特征辅助配准（FPFH-SAC）</strong>：</p>
<p>使用快速点特征直方图（FPFH）进行初始配准：</p>
<ol>
<li><strong>特征计算</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>对每个关键点p：

1. 计算k邻域内所有点对的(α, φ, θ)
2. 构建33维直方图
时间复杂度：O(nk)
</code></pre></div>

<ol start="2">
<li><strong>特征匹配</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>使用FLANN进行快速最近邻搜索
匹配条件：d₁/d₂ &lt; 0.8（Lowe&#39;s ratio test）
</code></pre></div>

<ol start="3">
<li><strong>RANSAC验证</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>从特征匹配中采样验证几何一致性
大幅减少迭代次数：N ≈ 10-20
</code></pre></div>

<p><strong>多尺度配准策略</strong>：</p>
<p>金字塔方法提高效率和鲁棒性：</p>
<div class="codehilite"><pre><span></span><code>Level 0: 体素0.4m, 10000点 → 粗配准
Level 1: 体素0.2m, 25000点 → 中配准  
Level 2: 体素0.1m, 50000点 → 精配准
Level 3: 原始点云         → 最终优化
</code></pre></div>

<p>每层参数设置：</p>
<div class="codehilite"><pre><span></span><code>Level  Max_iter  Convergence  Transform_eps
0      50        0.01m        0.001
1      30        0.005m       0.0005
2      20        0.002m       0.0001
3      10        0.001m       0.00005
</code></pre></div>

<p><strong>实际案例：城市场景配准</strong></p>
<p>场景描述：</p>
<ul>
<li>两帧64线激光雷达数据</li>
<li>车速30km/h，帧间隔0.1s</li>
<li>点云规模：各120000点</li>
<li>包含动态物体和遮挡</li>
</ul>
<p>配准流程：</p>
<ol>
<li>地面点移除（RANSAC）</li>
<li>体素降采样到30000点</li>
<li>FPFH特征提取（1000关键点）</li>
<li>RANSAC粗配准（20次迭代）</li>
<li>TrICP精配准（80%重叠率）</li>
</ol>
<p>结果：</p>
<div class="codehilite"><pre><span></span><code>总耗时：85ms
配准误差：1.8cm RMSE
内点率：82%
适合度：0.023m
</code></pre></div>

<h2 id="92-slam">9.2 SLAM算法</h2>
<p>同时定位与地图构建（Simultaneous Localization and Mapping）是激光雷达最重要的应用之一。SLAM使机器人能在未知环境中定位自身位置同时构建环境地图。现代激光雷达SLAM已广泛应用于自动驾驶、移动机器人和无人机等领域。</p>
<h3 id="921-slam">9.2.1 激光雷达SLAM框架</h3>
<p><strong>SLAM问题的概率表述</strong>：</p>
<p>完整的SLAM后验概率：</p>
<div class="codehilite"><pre><span></span><code>p(X₀:ₜ, M | Z₀:ₜ, U₀:ₜ) = p(M|X₀:ₜ,Z₀:ₜ) · p(X₀:ₜ|Z₀:ₜ,U₀:ₜ)
</code></pre></div>

<p>其中：</p>
<ul>
<li>X₀:ₜ：从0到t时刻的所有位姿</li>
<li>M：环境地图</li>
<li>Z₀:ₜ：所有观测数据</li>
<li>U₀:ₜ：所有控制输入</li>
</ul>
<p><strong>状态向量定义</strong>：</p>
<p>在SE(3)流形上的位姿表示：</p>
<div class="codehilite"><pre><span></span><code>X = [r, q]ᵀ ∈ ℝ³ × S³
</code></pre></div>

<p>其中：</p>
<ul>
<li>r = [x, y, z]ᵀ：位置向量</li>
<li>q = [qw, qx, qy, qz]ᵀ：四元数（避免欧拉角奇异性）</li>
</ul>
<p>或使用李代数表示：</p>
<div class="codehilite"><pre><span></span><code>ξ = [ρ, φ]ᵀ ∈ se(3)
</code></pre></div>

<p>其中ρ是平移，φ是旋转向量。</p>
<p><strong>运动模型</strong>：</p>
<p>考虑IMU预积分的运动模型：</p>
<div class="codehilite"><pre><span></span><code>rₜ = rₜ₋₁ + vₜ₋₁Δt + ½Rₜ₋₁(aₜ₋₁ - bₐ - nₐ)Δt²
vₜ = vₜ₋₁ + Rₜ₋₁(aₜ₋₁ - bₐ - nₐ)Δt
qₜ = qₜ₋₁ ⊗ exp(½(ωₜ₋₁ - bᵩ - nᵩ)Δt)
</code></pre></div>

<p>协方差传播：</p>
<div class="codehilite"><pre><span></span><code>Pₜ = FₜPₜ₋₁Fₜᵀ + GₜQₜGₜᵀ
</code></pre></div>

<p>其中F是状态转移矩阵，G是噪声输入矩阵。</p>
<p><strong>观测模型</strong>：</p>
<p>点到特征的观测方程：</p>
<div class="codehilite"><pre><span></span><code>zᵢ = h(Xₜ, fⱼ) + vᵢ
</code></pre></div>

<p>对于点到平面特征：</p>
<div class="codehilite"><pre><span></span><code>h(X, plane) = nᵀ(R(q)p + r - π₀)
</code></pre></div>

<p>其中n是平面法向量，π₀是平面上一点。</p>
<p><strong>地图表示</strong>：</p>
<ol>
<li><strong>特征地图</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nx">M</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="nx">f₁</span><span class="p">,</span><span class="w"> </span><span class="nx">f₂</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="nx">fₙ</span><span class="p">}</span>
<span class="nx">fᵢ</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="nx">params</span><span class="p">,</span><span class="w"> </span><span class="nx">Σ</span><span class="p">]</span>
</code></pre></div>

<ol start="2">
<li><strong>体素地图</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">M</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">ℝ³</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span><span class="w">  </span><span class="c1">// 占用概率</span>
</code></pre></div>

<ol start="3">
<li><strong>Surfel地图</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>M = {s₁, s₂, ..., sₘ}
sᵢ = [position, normal, radius, confidence]
</code></pre></div>

<p><strong>计算实例：单帧定位</strong></p>
<p>给定：</p>
<ul>
<li>当前位姿估计：X = [1,2,0.5, 0°,0°,30°]</li>
<li>观测到平面特征：n=[0,0,1], d=2m</li>
<li>点云中提取的平面点：p=[3,4,1.8]</li>
</ul>
<p>计算残差：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">变换点到世界坐标</span><span class="err">：</span>
<span class="w">   </span><span class="n">p_w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="mf">30</span><span class="err">°</span><span class="p">)</span><span class="err">·[</span><span class="mf">3</span><span class="p">,</span><span class="mf">4</span><span class="p">,</span><span class="mf">1.8</span><span class="err">]</span><span class="n">ᵀ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">[</span><span class="mf">1</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">0.5</span><span class="err">]</span><span class="n">ᵀ</span>
<span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="mf">2.60</span><span class="p">,</span><span class="w"> </span><span class="mf">5.46</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3</span><span class="err">]</span><span class="n">ᵀ</span>

<span class="mf">2.</span><span class="w"> </span><span class="n">点到平面距离</span><span class="err">：</span>
<span class="w">   </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">|</span><span class="n">n</span><span class="err">·</span><span class="n">p_w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">d</span><span class="err">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">|</span><span class="mf">1</span><span class="err">×</span><span class="mf">2.3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2</span><span class="err">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.3</span><span class="n">m</span>

<span class="mf">3.</span><span class="w"> </span><span class="n">雅可比矩阵</span><span class="err">（</span><span class="n">对位姿</span><span class="err">）：</span>
<span class="w">   </span><span class="err">∂</span><span class="n">e</span><span class="o">/</span><span class="err">∂</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="err">]</span>
<span class="w">   </span><span class="err">∂</span><span class="n">e</span><span class="o">/</span><span class="err">∂</span><span class="n">θ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="p">(</span><span class="n">R</span><span class="err">·</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="mf">5.46</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">2.60</span><span class="p">,</span><span class="w"> </span><span class="mf">0</span><span class="err">]</span>
</code></pre></div>

<h3 id="922">9.2.2 扫描匹配算法</h3>
<p>扫描匹配是激光雷达SLAM的核心，通过匹配连续帧间的几何特征实现位姿估计。</p>
<p><strong>特征提取详解</strong>：</p>
<ol>
<li><strong>曲率计算</strong>：
   对扫描线上的点pᵢ，局部曲率定义为：</li>
</ol>
<div class="codehilite"><pre><span></span><code>c = 1/(2k|pᵢ|²) · ‖Σⱼ₌₋ₖᵏ(pⱼ - pᵢ)‖²
</code></pre></div>

<p>考虑激光雷达的扫描特性：</p>
<ul>
<li>水平分辨率：Δθ = 0.2° (1800点/圈)</li>
<li>垂直分辨率：Δφ = 0.4° (64线)</li>
<li>邻域选择：k = 5（覆盖2°范围）</li>
</ul>
<ol start="2">
<li><strong>特征分类阈值</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="err">边缘特征</span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">cₑ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.2</span>
<span class="err">平面特征</span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cₚ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.05</span>
<span class="err">不稳定点</span><span class="o">:</span><span class="w"> </span><span class="n">cₚ</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="n">cₑ</span><span class="err">（丢弃）</span>
</code></pre></div>

<ol start="3">
<li><strong>特征筛选</strong>：
   - 遮挡边缘剔除：相邻点距离突变 &gt; 0.3m
   - 平行线剔除：避免退化情况
   - 均匀采样：每个扇区最多选20个特征</li>
</ol>
<p><strong>改进的特征提取（LOAM风格）</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="o">//</span><span class="w"> </span><span class="n">按扫描线组织点云</span>
<span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="nl">scan_line</span><span class="p">:</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">计算每个点的曲率</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="mi">5</span><span class="err">:</span>
<span class="w">        </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i-5</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i-4</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i+5</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">10</span><span class="o">*</span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
<span class="w">        </span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diff</span><span class="p">.</span><span class="n">norm</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="n">norm</span><span class="p">())</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">分扇区提取特征</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">sector</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="n">sectors</span><span class="w"> </span><span class="n">per</span><span class="w"> </span><span class="n">scan</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">sort</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">curvature</span>
<span class="w">        </span><span class="k">select</span><span class="w"> </span><span class="k">top</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="n">features</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.2</span><span class="p">)</span>
<span class="w">        </span><span class="k">select</span><span class="w"> </span><span class="n">bottom</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">planar</span><span class="w"> </span><span class="n">features</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.05</span><span class="p">)</span>
<span class="w">        </span><span class="n">mark</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">selectable</span>
</code></pre></div>

<p><strong>点到线距离计算</strong>：</p>
<p>给定边缘点p和地图中对应线段(p₁, p₂)：</p>
<ol>
<li><strong>解析形式</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>d = ‖(p - p₁) × (p₂ - p₁)‖ / ‖p₂ - p₁‖
</code></pre></div>

<ol start="2">
<li><strong>数值稳定计算</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 避免除零</span>
<span class="n">denominator</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>‖<span class="n">p₂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p₁</span>‖
<span class="k">if</span><span class="w"> </span><span class="n">denominator</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.1</span><span class="n">m</span><span class="p">:</span>
<span class="w">    </span><span class="n">use</span><span class="w"> </span><span class="n">point</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">point</span><span class="w"> </span><span class="n">distance</span>
<span class="k">else</span><span class="p">:</span>
<span class="w">    </span><span class="n">d</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cross_product</span><span class="p">.</span><span class="nb">norm</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">denominator</span>
</code></pre></div>

<ol start="3">
<li><strong>权重设计</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>w = exp(-d²/σ²) · (1 - |cos(θ)|)
</code></pre></div>

<p>其中θ是观测方向与线段的夹角。</p>
<p><strong>点到面距离计算</strong>：</p>
<ol>
<li><strong>平面拟合</strong>（最小二乘）：
   给定点集{p₁, p₂, p₃, ...}：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="err">质心</span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">Σ</span><span class="n">pᵢ</span><span class="o">/</span><span class="n">n</span>
<span class="err">协方差</span><span class="o">:</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">Σ</span><span class="o">(</span><span class="n">pᵢ</span><span class="o">-</span><span class="n">c</span><span class="o">)(</span><span class="n">pᵢ</span><span class="o">-</span><span class="n">c</span><span class="o">)</span><span class="err">ᵀ</span>
<span class="err">法向量</span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eigenvector</span><span class="o">(</span><span class="n">C</span><span class="o">,</span><span class="w"> </span><span class="err">λ</span><span class="n">_min</span><span class="o">)</span>
<span class="err">距离</span><span class="o">:</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="err">·</span><span class="n">c</span>
</code></pre></div>

<ol start="2">
<li><strong>快速近似</strong>（三点法）：</li>
</ol>
<div class="codehilite"><pre><span></span><code>n = (p₂ - p₁) × (p₃ - p₁)
n = n / ‖n‖
d = n·(p - p₁)
</code></pre></div>

<ol start="3">
<li><strong>鲁棒性检查</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 检查三点是否接近共线</span>
<span class="k">if</span><span class="w"> </span>‖<span class="n">n</span>‖<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.1</span><span class="p">:</span>
<span class="w">    </span><span class="n">mark</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">invalid</span>
<span class="c1">// 检查点是否在平面附近</span>
<span class="k">if</span><span class="w"> </span><span class="o">|</span><span class="n">d</span><span class="o">|</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span>σ<span class="n">_noise</span><span class="p">:</span>
<span class="w">    </span><span class="n">reduce</span><span class="w"> </span><span class="n">weight</span>
</code></pre></div>

<p><strong>非线性优化求解</strong>：</p>
<p>构建最小二乘问题：</p>
<div class="codehilite"><pre><span></span><code>min f(X) = Σᵢ₌₁ᵐ ρ(eᵢᵀWᵢeᵢ)
</code></pre></div>

<p>其中ρ是鲁棒核函数（如Huber）。</p>
<ol>
<li><strong>Gauss-Newton迭代</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nl">repeat</span><span class="p">:</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">计算雅可比和残差</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">feature</span><span class="w"> </span><span class="nl">correspondence</span><span class="p">:</span>
<span class="w">        </span><span class="n">e</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_error</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">feature</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="n">J</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_jacobian</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">feature</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">构建正规方程</span>
<span class="w">    </span><span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JᵀWJ</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">JᵀWe</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">求解增量</span>
<span class="w">    </span><span class="n">ΔX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Cholesky分解</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">更新状态</span><span class="err">（</span><span class="n">流形上</span><span class="err">）</span>
<span class="w">    </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">⊞</span><span class="w"> </span><span class="n">ΔX</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">SE</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="n">上的更新</span>
<span class="n">until</span><span class="w"> </span><span class="n">convergence</span>
</code></pre></div>

<ol start="2">
<li><strong>雅可比矩阵推导</strong>：</li>
</ol>
<p>对于点p经变换T后到平面(n,d)的距离：</p>
<div class="codehilite"><pre><span></span><code><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nᵀ</span><span class="p">(</span><span class="n">Rp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">d</span>

<span class="err">∂</span><span class="n">e</span><span class="o">/</span><span class="err">∂</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span>
<span class="err">∂</span><span class="n">e</span><span class="o">/</span><span class="err">∂</span><span class="n">θ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">nᵀR</span><span class="o">[</span><span class="n">p</span><span class="o">]</span><span class="n">ₓ</span>
</code></pre></div>

<p>其中[p]ₓ是p的反对称矩阵。</p>
<p><strong>计算实例：一次迭代</strong></p>
<p>场景设置：</p>
<ul>
<li>当前位姿：X = [0,0,0, 0°,0°,0°]</li>
<li>提取特征：20个边缘点，40个平面点</li>
<li>地图特征：已有500个边缘，1000个平面</li>
</ul>
<p>优化过程：</p>
<div class="codehilite"><pre><span></span><code><span class="err">迭代</span><span class="mi">0</span><span class="o">:</span>
<span class="err">残差向量</span><span class="n">e</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">60</span><span class="err">×</span><span class="mi">1</span><span class="o">],</span><span class="w"> </span><span class="n">RMS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.15</span><span class="n">m</span>
<span class="err">雅可比</span><span class="n">J</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">60</span><span class="err">×</span><span class="mi">6</span><span class="o">]</span>
<span class="err">信息矩阵</span><span class="n">H</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">6</span><span class="err">×</span><span class="mi">6</span><span class="o">]</span>
<span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="mi">120</span><span class="w">   </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="o">-</span><span class="mi">50</span><span class="w">   </span><span class="mi">80</span><span class="w">    </span><span class="mi">0</span><span class="w">  </span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="mi">0</span><span class="w">    </span><span class="mi">130</span><span class="w">   </span><span class="mi">0</span><span class="w">    </span><span class="mi">40</span><span class="w">   </span><span class="mi">0</span><span class="w">    </span><span class="o">-</span><span class="mi">60</span><span class="w"> </span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="mi">0</span><span class="w">     </span><span class="mi">0</span><span class="w">   </span><span class="mi">150</span><span class="w">   </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">     </span><span class="mi">0</span><span class="w">  </span><span class="o">]</span>
<span class="w">    </span><span class="o">[-</span><span class="mi">50</span><span class="w">   </span><span class="mi">40</span><span class="w">   </span><span class="mi">0</span><span class="w">   </span><span class="mi">800</span><span class="w">   </span><span class="mi">0</span><span class="w">     </span><span class="mi">0</span><span class="w">  </span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="mi">80</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="mi">850</span><span class="w">    </span><span class="mi">0</span><span class="w">  </span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="mi">0</span><span class="w">   </span><span class="o">-</span><span class="mi">60</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">900</span><span class="w"> </span><span class="o">]</span>

<span class="err">解得：Δ</span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="mf">0.05</span><span class="o">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.03</span><span class="o">,</span><span class="w"> </span><span class="mf">0.01</span><span class="o">,</span><span class="w"> </span><span class="mf">0.002</span><span class="o">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.001</span><span class="o">,</span><span class="w"> </span><span class="mf">0.003</span><span class="o">]</span>
<span class="err">更新：</span><span class="n">X_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">⊞</span><span class="w"> </span><span class="err">Δ</span><span class="n">X</span>
<span class="err">新残差</span><span class="n">RMS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.08</span><span class="n">m</span>
</code></pre></div>

<p><strong>退化检测与处理</strong>：</p>
<p>某些场景（如长走廊）会导致特定方向约束不足：</p>
<ol>
<li><strong>可观性分析</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 计算信息矩阵的特征值</span>
<span class="n">eigenvalues</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1200</span><span class="p">,</span><span class="w"> </span><span class="mi">980</span><span class="p">,</span><span class="w"> </span><span class="mi">850</span><span class="p">,</span><span class="w"> </span><span class="mi">120</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">]</span>

<span class="c1">// 检测退化方向</span>
<span class="k">if</span><span class="w"> </span>λ<span class="n">_min</span><span class="w"> </span><span class="o">/</span><span class="w"> </span>λ<span class="n">_max</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.001</span><span class="p">:</span>
<span class="w">    </span><span class="n">degenerate_direction</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">eigenvector</span><span class="p">(</span>λ<span class="n">_min</span><span class="p">)</span>
</code></pre></div>

<ol start="2">
<li><strong>约束投影</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="o">//</span><span class="w"> </span><span class="err">只在可观测方向更新</span>
<span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_degen</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">v_degen</span><span class="o">^</span><span class="n">T</span>
<span class="err">Δ</span><span class="n">X_constrained</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="err">Δ</span><span class="n">X</span>
</code></pre></div>

<h3 id="923-hessian">9.2.3 Hessian矩阵计算</h3>
<p>对于6自由度优化，Hessian矩阵H是6×6对称正定矩阵，其结构和数值特性直接影响优化的收敛性。</p>
<p><strong>李代数框架下的雅可比推导</strong>：</p>
<p>使用se(3)李代数参数化：ξ = [ρ, φ]ᵀ ∈ ℝ⁶</p>
<ol>
<li><strong>指数映射</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>exp(ξ^) = [exp(φ^)  Jρ]
          [0         1 ]
</code></pre></div>

<p>其中J是左雅可比：
   <code>J = I + (1-cos‖φ‖)/‖φ‖² φ^ + (‖φ‖-sin‖φ‖)/‖φ‖³ φ^²</code></p>
<ol start="2">
<li><strong>扰动模型</strong>：
   对于点p的变换：</li>
</ol>
<div class="codehilite"><pre><span></span><code>T(ξ)p = exp(ξ^)p = Rp + t
</code></pre></div>

<p>扰动导数：
   <code>∂(Tp)/∂ξ = lim[ε→0] (exp(εξ^)Tp - Tp)/ε
             = [I  -[Rp]ₓ]</code></p>
<p><strong>特征对应的雅可比矩阵</strong>：</p>
<ol>
<li><strong>点到平面</strong>：
   残差：e = nᵀ(Rp + t - q)</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">Je</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∂</span><span class="n">e</span><span class="o">/</span><span class="err">∂</span><span class="n">ξ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nᵀ</span><span class="o">[</span><span class="n">I  -[Rp</span><span class="o">]</span><span class="n">ₓ</span><span class="err">]</span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">nₓ  nᵧ  nᵤ  -nᵀ[Rp</span><span class="o">]</span><span class="n">ₓ</span><span class="err">]</span>
</code></pre></div>

<ol start="2">
<li><strong>点到线</strong>：
   残差：e = ‖(Rp+t-a)×l‖，其中l是线方向</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">Je</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∂</span><span class="n">e</span><span class="o">/</span><span class="err">∂</span><span class="n">ξ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">(l×u)ᵀ/‖e‖  -(l×[Rp</span><span class="o">]</span><span class="n">ₓu</span><span class="p">)</span><span class="n">ᵀ</span><span class="o">/</span><span class="err">‖</span><span class="n">e</span><span class="err">‖]</span>
</code></pre></div>

<p>其中u = Rp + t - a</p>
<ol start="3">
<li><strong>点到点</strong>：
   残差：e = Rp + t - q</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">Je</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∂</span><span class="n">e</span><span class="o">/</span><span class="err">∂</span><span class="n">ξ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">I₃ₓ₃  -[Rp</span><span class="o">]</span><span class="n">ₓ</span><span class="err">]</span>
</code></pre></div>

<p><strong>信息矩阵构建</strong>：</p>
<p>考虑不同特征的不确定性：</p>
<div class="codehilite"><pre><span></span><code>H = Σᵢ JᵢᵀWᵢJᵢ
</code></pre></div>

<p>权重矩阵设计：</p>
<ol>
<li><strong>距离衰减</strong>：wᵢ = 1/dᵢ²</li>
<li><strong>入射角</strong>：wᵢ = |cos(θᵢ)|</li>
<li><strong>特征质量</strong>：wᵢ = exp(-σᵢ²/σ₀²)</li>
</ol>
<p><strong>详细计算实例</strong>：</p>
<p>场景：10个平面特征，5个边缘特征</p>
<div class="codehilite"><pre><span></span><code><span class="o">//</span><span class="w"> </span><span class="n">初始化</span>
<span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="o">//</span><span class="w"> </span><span class="n">平面特征贡献</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="mi">10</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plane</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="n">normal</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="o">[</span><span class="n">0.1, 0.2, 0.97</span><span class="o">]</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w">         </span><span class="o">//</span><span class="w"> </span><span class="o">[</span><span class="n">5.0, 3.0, 1.0</span><span class="o">]</span>
<span class="w">    </span><span class="n">Rp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="n">变换后的点</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">雅可比</span><span class="w"> </span><span class="mi">1</span><span class="err">×</span><span class="mi">6</span>
<span class="w">    </span><span class="n">J_plane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">n&#39;  -n&#39;*skew(Rp)</span><span class="o">]</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">残差</span>
<span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="s1">&#39;*(Rp + t) - plane[i].d</span>

<span class="s1">    // 累加</span>
<span class="s1">    H += J_plane&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">J_plane</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">J_plane</span><span class="s1">&#39; * w[i] * e</span>
<span class="s1">end</span>

<span class="s1">// 边缘特征贡献</span>
<span class="s1">for i = 1:5</span>
<span class="s1">    // 复杂的线特征雅可比...</span>
<span class="s1">    J_edge = compute_edge_jacobian(...)</span>
<span class="s1">    H += J_edge&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w_edge</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">J_edge</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">J_edge</span><span class="err">&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w_edge</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">e_edge</span>
<span class="k">end</span>

<span class="o">//</span><span class="w"> </span><span class="n">最终Hessian矩阵结构</span>
<span class="n">H</span><span class="w"> </span><span class="err">≈</span><span class="w"> </span><span class="o">[</span><span class="n">150   20   -10   -80   120    50</span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="n">20   180    15    60   -40   -90</span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="n">-10   15   200     5    10    20</span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="n">-80   60     5  1200  -200  -150</span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="n">120  -40    10  -200  1500   100</span><span class="o">]</span>
<span class="w">    </span><span class="o">[</span><span class="n">50   -90    20  -150   100  1800</span><span class="o">]</span>

<span class="o">//</span><span class="w"> </span><span class="n">条件数检查</span>
<span class="n">cond</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">λ_max</span><span class="o">/</span><span class="n">λ_min</span><span class="w"> </span><span class="err">≈</span><span class="w"> </span><span class="mi">120</span>
</code></pre></div>

<p><strong>数值稳定性优化</strong>：</p>
<ol>
<li><strong>Levenberg-Marquardt正则化</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>H_lm = H + λI
λ = λ₀ * max(diag(H))
</code></pre></div>

<ol start="2">
<li><strong>预条件技术</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// Jacobi预条件</span>
<span class="n">D</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">diag</span><span class="p">(</span><span class="nb">diag</span><span class="p">(</span><span class="n">H</span><span class="p">))</span>
<span class="n">H_precond</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">D</span>^<span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">D</span>^<span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>

<ol start="3">
<li><strong>Cholesky分解</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>L = cholesky(H)
y = forward_substitution(L, b)
Δξ = back_substitution(L&#39;, y)
</code></pre></div>

<p><strong>稀疏性利用</strong>：</p>
<p>大规模SLAM中H具有稀疏结构：</p>
<div class="codehilite"><pre><span></span><code><span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">H_pp</span><span class="w">  </span><span class="n">H_pm</span><span class="p">]</span><span class="w">  </span><span class="c1">// p: poses, m: map</span>
<span class="w">    </span><span class="p">[</span><span class="n">H_mp</span><span class="w">  </span><span class="n">H_mm</span><span class="p">]</span>
</code></pre></div>

<p>使用Schur补：</p>
<div class="codehilite"><pre><span></span><code>(H_pp - H_pm <span class="gs">* H_mm^(-1) *</span> H_mp) <span class="gs">* Δp = b_p - H_pm *</span> H_mm^(-1) * b_m
</code></pre></div>

<h3 id="924">9.2.4 回环检测</h3>
<p>回环检测是SLAM长期一致性的关键，通过识别重访位置消除累积误差。</p>
<p><strong>全局描述子设计</strong>：</p>
<ol>
<li><strong>Scan Context实现细节</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="o">//</span><span class="w"> </span><span class="n">参数设置</span>
<span class="n">N_sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">60</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">每6</span><span class="err">°</span><span class="n">一个扇区</span>
<span class="n">N_ring</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">环宽度2</span><span class="mf">.5</span><span class="n">m</span><span class="err">（</span><span class="n">最大50m</span><span class="err">）</span>
<span class="n">L_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">50.0</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">最大感知距离</span>

<span class="o">//</span><span class="w"> </span><span class="n">构建描述子</span>
<span class="k">for</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">pointcloud</span><span class="p">:</span>
<span class="w">    </span><span class="n">θ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atan2</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">sqrt</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">y²</span><span class="p">)</span>

<span class="w">    </span><span class="n">sector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">floor</span><span class="p">(</span><span class="n">θ</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="n">π</span><span class="o">/</span><span class="n">N_sector</span><span class="p">))</span>
<span class="w">    </span><span class="n">ring</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">floor</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="p">(</span><span class="n">L_max</span><span class="o">/</span><span class="n">N_ring</span><span class="p">))</span>

<span class="w">    </span><span class="n">SC</span><span class="o">[</span><span class="n">ring</span><span class="o">][</span><span class="n">sector</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">SC</span><span class="o">[</span><span class="n">ring</span><span class="o">][</span><span class="n">sector</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
</code></pre></div>

<ol start="2">
<li><strong>增强版Scan Context++</strong>：
   加入强度和密度信息：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">SC_intensity</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mean</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span>
<span class="n">SC_density</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">/</span><span class="n">volume</span>
</code></pre></div>

<ol start="3">
<li><strong>旋转不变匹配</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="o">//</span><span class="w"> </span><span class="n">列循环移位寻找最佳对齐</span>
<span class="n">min_dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inf</span>
<span class="n">best_shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>

<span class="k">for</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">N_sector</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">N_ring</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">N_sector</span><span class="p">)</span><span class="err">:</span>
<span class="w">            </span><span class="n">j_shifted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shift</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N_sector</span>
<span class="w">            </span><span class="n">dist</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">|</span><span class="n">SC1</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">SC2</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j_shifted</span><span class="o">]|</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nl">min_dist</span><span class="p">:</span>
<span class="w">        </span><span class="n">min_dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dist</span>
<span class="w">        </span><span class="n">best_shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shift</span>

<span class="n">yaw_diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">best_shift</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="n">π</span><span class="o">/</span><span class="n">N_sector</span><span class="p">)</span>
</code></pre></div>

<p><strong>快速候选搜索</strong>：</p>
<ol>
<li><strong>KD树索引</strong>：
   将描述子展开为向量，构建KD树</li>
</ol>
<div class="codehilite"><pre><span></span><code>feature = flatten(SC) // 1200维向量
kdtree.insert(feature, frame_id)
</code></pre></div>

<ol start="2">
<li><strong>Ring Key优化</strong>：
   使用环形结构快速过滤</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">ring_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Σᵢ</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Σⱼ</span><span class="w"> </span><span class="n">SC</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
<span class="n">candidates</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frames</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="o">|</span><span class="n">ring_key_diff</span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">threshold</span>
</code></pre></div>

<ol start="3">
<li><strong>时间约束</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 避免短期回环</span>
<span class="k">if</span><span class="w"> </span><span class="o">|</span><span class="n">current_time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">candidate_time</span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">30</span><span class="n">s</span><span class="p">:</span>
<span class="w">    </span><span class="n">skip</span>
</code></pre></div>

<p><strong>几何验证流程</strong>：</p>
<ol>
<li><strong>粗配准</strong>：
   使用描述子匹配得到的角度初值</li>
</ol>
<div class="codehilite"><pre><span></span><code>R_init = Rz(yaw_diff)
t_init = t_current - R_init * t_candidate
</code></pre></div>

<ol start="2">
<li><strong>GICP精配准</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="o">//</span><span class="w"> </span><span class="err">降采样</span>
<span class="n">source_down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">voxel_downsample</span><span class="p">(</span><span class="n">current_scan</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="n">m</span><span class="p">)</span>
<span class="n">target_down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">voxel_downsample</span><span class="p">(</span><span class="n">candidate_scan</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="n">m</span><span class="p">)</span>

<span class="o">//</span><span class="w"> </span><span class="err">计算法向量和协方差</span>
<span class="n">compute_normals_and_covariance</span><span class="p">(</span><span class="n">source_down</span><span class="p">)</span>
<span class="n">compute_normals_and_covariance</span><span class="p">(</span><span class="n">target_down</span><span class="p">)</span>

<span class="o">//</span><span class="w"> </span><span class="n">GICP优化</span>
<span class="n">T_refined</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gicp_align</span><span class="p">(</span><span class="n">source_down</span><span class="p">,</span><span class="w"> </span><span class="n">target_down</span><span class="p">,</span><span class="w"> </span><span class="n">T_init</span><span class="p">)</span>
</code></pre></div>

<ol start="3">
<li><strong>一致性检查</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 适合度分数</span>
<span class="n">fitness</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">compute_fitness</span><span class="p">(</span><span class="n">T_refined</span><span class="p">)</span>

<span class="c1">// 要求：</span>
<span class="c1">// 1. 内点率 &gt; 70%</span>
<span class="c1">// 2. 适合度 &lt; 0.3m</span>
<span class="c1">// 3. 变换合理性：平移 &lt; 5m，旋转 &lt; 30°</span>
</code></pre></div>

<p><strong>实际案例：停车场场景</strong></p>
<p>场景特征：</p>
<ul>
<li>环境：地下停车场，柱子规则排列</li>
<li>轨迹：绕行一圈，约500m</li>
<li>挑战：结构重复，易产生错误回环</li>
</ul>
<p>检测过程：</p>
<div class="codehilite"><pre><span></span><code>Frame 1200 (当前帧):

1. 构建Scan Context描述子
2. KD树搜索最近的10个候选
3. 候选帧：[156, 178, 245, 890, 1156]

验证Frame 156:

- 描述子距离：285.3
- 初始角度差：30°
- GICP后适合度：0.18m
- 内点率：85%
→ 接受为回环

验证Frame 890:

- 描述子距离：198.2  
- 初始角度差：0°
- GICP后适合度：1.2m
- 内点率：35%
→ 拒绝（错误匹配）
</code></pre></div>

<h3 id="925-slam">9.2.5 图优化SLAM</h3>
<p><strong>因子图表示</strong>：</p>
<ul>
<li>节点：机器人位姿Xᵢ</li>
<li>边：约束关系（里程计、回环）</li>
</ul>
<p><strong>误差函数</strong>：</p>
<div class="codehilite"><pre><span></span><code>F = Σᵢⱼ eᵢⱼᵀΩᵢⱼeᵢⱼ
</code></pre></div>

<p>其中：</p>
<ul>
<li>eᵢⱼ = Xⱼ - f(Xᵢ, zᵢⱼ)：残差</li>
<li>Ωᵢⱼ：信息矩阵</li>
</ul>
<p><strong>优化求解</strong>：
使用Levenberg-Marquardt算法：</p>
<div class="codehilite"><pre><span></span><code>(H + λI)Δ = -b
</code></pre></div>

<p><strong>稀疏性利用</strong>：
Hessian矩阵高度稀疏，使用Schur补技巧：</p>
<div class="codehilite"><pre><span></span><code>计算复杂度：O(n³) → O(n)
</code></pre></div>

<h3 id="926">9.2.6 实时性优化</h3>
<p><strong>关键帧策略</strong>：</p>
<ul>
<li>平移 &gt; 0.5m 或 旋转 &gt; 10°时添加关键帧</li>
<li>保持活跃地图大小 &lt; 1000个特征</li>
</ul>
<p><strong>并行化</strong>：</p>
<ol>
<li>特征提取：GPU并行</li>
<li>KD-tree构建：多线程</li>
<li>优化求解：增量式更新</li>
</ol>
<p><strong>计算预算</strong>：
典型10Hz激光雷达：</p>
<ul>
<li>特征提取：20ms</li>
<li>扫描匹配：50ms</li>
<li>地图更新：20ms</li>
<li>总延迟：&lt;100ms</li>
</ul>
<h2 id="93">9.3 目标检测</h2>
<p>激光雷达点云的目标检测是自动驾驶和机器人感知的核心任务。本节介绍从传统聚类方法到深度学习的各种检测算法。</p>
<h3 id="931-dbscan">9.3.1 DBSCAN聚类算法</h3>
<p>DBSCAN（Density-Based Spatial Clustering）是一种基于密度的聚类算法，特别适合处理激光雷达点云。</p>
<p><strong>算法参数</strong>：</p>
<ul>
<li>ε：邻域半径</li>
<li>MinPts：最小点数</li>
</ul>
<p><strong>点的分类</strong>：</p>
<ol>
<li><strong>核心点</strong>：ε邻域内点数 ≥ MinPts</li>
<li><strong>边界点</strong>：在某核心点的ε邻域内，但自身不是核心点</li>
<li><strong>噪声点</strong>：既不是核心点也不是边界点</li>
</ol>
<p><strong>算法步骤</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">对每个点p</span><span class="err">：</span>
<span class="w">   </span><span class="n">计算Nε</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="n">q</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="n">ε</span><span class="err">}</span>

<span class="mf">2.</span><span class="w"> </span><span class="n">如果</span><span class="err">|</span><span class="n">Nε</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="err">|</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="n">MinPts</span><span class="err">，</span><span class="n">标记p为核心点</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">对每个核心点p</span><span class="err">：</span>
<span class="w">   </span><span class="n">如果p未被访问</span><span class="err">，</span><span class="n">创建新簇C</span>
<span class="w">   </span><span class="n">将Nε</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="n">中所有点加入C</span>
<span class="w">   </span><span class="n">递归扩展簇</span>
</code></pre></div>

<p><strong>参数选择</strong>：</p>
<ul>
<li>车辆检测：ε = 0.5m, MinPts = 10</li>
<li>行人检测：ε = 0.3m, MinPts = 5</li>
<li>建筑物：ε = 1.0m, MinPts = 20</li>
</ul>
<p><strong>计算优化</strong>：
使用KD-tree加速邻域查询：</p>
<div class="codehilite"><pre><span></span><code>构建时间：O(n log n)
查询时间：O(log n)
总复杂度：O(n log n)
</code></pre></div>

<h3 id="932-3d">9.3.2 3D边界框拟合</h3>
<p>对聚类后的点云拟合3D边界框，用于确定目标的位置、尺寸和朝向。</p>
<p><strong>主成分分析（PCA）方法</strong>：</p>
<ol>
<li><strong>计算质心</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>c = (1/n)Σᵢpᵢ
</code></pre></div>

<ol start="2">
<li><strong>协方差矩阵</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>C = (1/n)Σᵢ(pᵢ - c)(pᵢ - c)ᵀ
</code></pre></div>

<ol start="3">
<li><strong>特征值分解</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>C = VΛVᵀ
</code></pre></div>

<p>其中V的列向量是主轴方向，λ₁ ≥ λ₂ ≥ λ₃</p>
<ol start="4">
<li><strong>边界框参数</strong>：
   - 中心：c
   - 朝向：v₁（最大特征值对应的特征向量）
   - 尺寸：在各主轴投影的范围</li>
</ol>
<p><strong>L-Shape拟合（车辆专用）</strong>：</p>
<p>车辆通常呈L形，可用两条垂直边拟合：</p>
<ol>
<li><strong>搜索角度</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>θ ∈ [0°, 90°]，步长Δθ = 1°
</code></pre></div>

<ol start="2">
<li><strong>投影计算</strong>：
   对每个角度θ，将点云投影到x-y平面：</li>
</ol>
<div class="codehilite"><pre><span></span><code>x&#39; = x cos θ + y sin θ
y&#39; = -x sin θ + y cos θ
</code></pre></div>

<ol start="3">
<li><strong>矩形度评分</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>score = Σ(edge_points) / total_points
</code></pre></div>

<ol start="4">
<li><strong>最优角度</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>θ* = argmax score(θ)
</code></pre></div>

<p><strong>计算实例</strong>：
假设检测到100个点的车辆点云：</p>
<ul>
<li>PCA计算：100×3×3 = 900次乘法</li>
<li>L-Shape搜索：90×100×4 = 36000次运算</li>
<li>典型耗时：&lt;1ms/目标</li>
</ul>
<h3 id="933">9.3.3 基于体素的快速检测</h3>
<p><strong>体素化预处理</strong>：
将3D空间划分为规则网格：</p>
<div class="codehilite"><pre><span></span><code>体素大小：0.1m × 0.1m × 0.1m
空间范围：[-50m, 50m] × [-50m, 50m] × [-3m, 2m]
体素数量：1000 × 1000 × 50 = 5×10⁷
</code></pre></div>

<p><strong>特征提取</strong>：
每个体素的特征：</p>
<ul>
<li>点数：n</li>
<li>平均高度：z̄</li>
<li>高度方差：σz²</li>
<li>反射强度：Ī</li>
</ul>
<p><strong>连通域分析</strong>：
使用3D连通域标记：</p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="nv">voxel</span>[<span class="nv">i</span>,<span class="nv">j</span>,<span class="nv">k</span>].<span class="nv">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nv">threshold</span>:
<span class="w">    </span><span class="nv">label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">BFS</span><span class="ss">(</span><span class="nv">i</span>,<span class="nv">j</span>,<span class="nv">k</span><span class="ss">)</span>
</code></pre></div>

<p><strong>性能优势</strong>：</p>
<ul>
<li>固定计算复杂度：O(V)，V是体素数</li>
<li>易于GPU并行化</li>
<li>内存访问局部性好</li>
</ul>
<h3 id="934">9.3.4 点云深度学习检测</h3>
<p><strong>PointNet架构</strong>：</p>
<ol>
<li><strong>对称函数</strong>：
   使用max pooling实现排列不变性：</li>
</ol>
<div class="codehilite"><pre><span></span><code>g(x₁,...,xₙ) = max{h(xᵢ)}
</code></pre></div>

<ol start="2">
<li>
<p><strong>T-Net</strong>：
   学习3×3和64×64变换矩阵，实现旋转不变性</p>
</li>
<li>
<p><strong>特征提取</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code>MLP(3) → MLP(64) → MLP(128) → MLP(1024) → max pool
</code></pre></div>

<p><strong>PointPillars（实时检测）</strong>：</p>
<ol>
<li>
<p><strong>Pillar生成</strong>：
   - 将点云投影到2D网格
   - 每个pillar最多N个点（N=32）
   - 特征：[x, y, z, r, xc, yc, zc, xp, yp]</p>
</li>
<li>
<p><strong>特征编码</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code>简化PointNet：MLP(64) → max pool
</code></pre></div>

<ol start="3">
<li><strong>2D CNN检测</strong>：
   使用标准2D检测器（如SSD）</li>
</ol>
<p><strong>性能指标</strong>：</p>
<ul>
<li>PointPillars：23ms@12.4Hz</li>
<li>SECOND：50ms@20Hz</li>
<li>PV-RCNN：80ms@12.5Hz</li>
</ul>
<h3 id="935">9.3.5 多类别检测策略</h3>
<p><strong>类别定义</strong>：</p>
<ol>
<li>车辆：长3-5m，宽1.5-2m，高1-2m</li>
<li>行人：半径0.3m，高1.5-2m</li>
<li>骑行者：长2m，宽0.8m，高1.8m</li>
<li>卡车：长&gt;6m，宽&gt;2.5m，高&gt;2.5m</li>
</ol>
<p><strong>级联检测</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">地面分割</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">去除地面点</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">高度滤波</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">分离不同高度目标</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">聚类</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">按大小分组</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">分类</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">针对性检测</span>
</code></pre></div>

<p><strong>难例处理</strong>：</p>
<ol>
<li><strong>遮挡</strong>：使用可见性推理</li>
<li><strong>远距离</strong>：自适应降低分辨率要求</li>
<li><strong>稀疏点</strong>：结合时序信息</li>
</ol>
<h3 id="936">9.3.6 检测性能评估</h3>
<p><strong>评价指标</strong>：</p>
<ol>
<li><strong>IoU（交并比）</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>IoU = Volume(GT ∩ Pred) / Volume(GT ∪ Pred)
</code></pre></div>

<ol start="2">
<li><strong>AP（平均精度）</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code>AP = ∫₀¹ p(r)dr
</code></pre></div>

<ol start="3">
<li><strong>距离误差</strong>：
   - 位置误差：Δd = ‖dGT - dpred‖
   - 角度误差：Δθ = |θGT - θpred|
   - 尺寸误差：Δs = |sGT - spred|/sGT</li>
</ol>
<p><strong>基准数据集性能</strong>：
KITTI 3D检测（Car, Moderate）：</p>
<ul>
<li>PointPillars：82.58% AP</li>
<li>SECOND：83.34% AP  </li>
<li>PV-RCNN：90.25% AP</li>
</ul>
<p><strong>实时性要求</strong>：
自动驾驶系统：</p>
<ul>
<li>检测延迟：&lt;50ms</li>
<li>跟踪更新：10Hz</li>
<li>端到端延迟：&lt;100ms</li>
</ul>
<h2 id="_1">本章小结</h2>
<p>本章深入介绍了激光雷达点云处理的三大核心算法：</p>
<ol>
<li>
<p><strong>点云配准</strong>：
   - ICP算法通过迭代优化实现精确配准，收敛速度快但对初值敏感
   - NDT算法将点云表示为概率分布，鲁棒性更强
   - 配准精度可达毫米级，是多帧融合的基础</p>
</li>
<li>
<p><strong>SLAM算法</strong>：
   - 通过特征提取和扫描匹配实现实时定位
   - 回环检测确保长时间运行的一致性
   - 图优化框架统一处理各种约束关系
   - 实时性要求严格，需要精心的系统设计</p>
</li>
<li>
<p><strong>目标检测</strong>：
   - 传统方法（DBSCAN）简单高效，适合实时应用
   - 深度学习方法精度更高，但计算量大
   - 多尺度、多类别检测需要综合策略
   - 性能评估需考虑精度和实时性的平衡</p>
</li>
</ol>
<p>关键公式汇总：</p>
<ul>
<li>ICP误差：E = Σ‖R·pᵢ + t - qᵢ‖²</li>
<li>NDT概率：p(x) = exp(-((x-μ)ᵀΣ⁻¹(x-μ))/2)</li>
<li>SLAM优化：F = Σeᵢⱼᵀ Ωᵢⱼ eᵢⱼ</li>
<li>DBSCAN密度：|Nε(p)| ≥ MinPts</li>
<li>IoU指标：IoU = Volume(GT ∩ Pred) / Volume(GT ∪ Pred)</li>
</ul>
<h2 id="_2">练习题</h2>
<h3 id="_3">基础题</h3>
<ol>
<li><strong>ICP收敛性分析</strong>
   给定两个2D点云，源点云旋转30°、平移(2,1)得到目标点云。计算需要多少次ICP迭代才能收敛到1mm精度？</li>
</ol>
<p><em>Hint: 使用误差指数衰减模型εₖ = ε₀ × 0.6ᵏ</em></p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   初始误差：ε₀ ≈ √(2² + 1²) = 2.24m
   目标误差：0.001m
   迭代次数：k = log(0.001/2.24)/log(0.6) ≈ 15次
   </details>
<ol start="2">
<li><strong>NDT格子大小选择</strong>
   对于100m×100m的停车场场景，点云密度为100点/m²，如何选择最优的NDT格子大小？</li>
</ol>
<p><em>Hint: 考虑每个格子内应有足够的点数（&gt;20）来估计高斯分布</em></p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   每个格子期望点数 = 格子面积 × 点密度
   若要求&gt;20点，则格子面积 &gt; 0.2m²
   最优格子大小：0.5m×0.5m（25个点/格子）
   </details>
<ol start="3">
<li><strong>SLAM关键帧选择</strong>
   机器人以0.5m/s速度直行，激光雷达10Hz，视场角270°。多久添加一次关键帧最合适？</li>
</ol>
<p><em>Hint: 考虑点云重叠率应保持在50%以上</em></p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   每秒移动0.5m，每帧间隔0.1s移动0.05m
   若要求50%重叠，关键帧间距应&lt;探测范围的一半
   建议每10帧（1秒）或移动0.5m时添加关键帧
   </details>
<ol start="4">
<li><strong>DBSCAN参数估计</strong>
   已知车辆点云密度约50点/m²，车辆最小尺寸3m×1.5m，如何设置DBSCAN参数？</li>
</ol>
<p><em>Hint: MinPts应确保小车也能被检测到</em></p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   最小车辆面积：4.5m²
   期望点数：4.5×50 = 225点
   考虑遮挡，设MinPts = 100
   ε = 0.5m（相邻点距离）
   </details>
<h3 id="_4">挑战题</h3>
<ol start="5">
<li><strong>多尺度ICP优化</strong>
   设计一个三层金字塔的多尺度ICP算法，给出每层的降采样率、收敛阈值和最大迭代次数。分析总体计算复杂度相比原始ICP的改进。</li>
</ol>
<p><em>Hint: 考虑点云规模与精度的权衡</em></p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   第1层：1/8降采样，阈值0.1m，最多20次
   第2层：1/4降采样，阈值0.05m，最多15次
   第3层：全分辨率，阈值0.01m，最多10次
   复杂度：O(n/8×20 + n/4×15 + n×10) ≈ O(14n)
   相比原始O(50n)，提速3.5倍
   </details>
<ol start="6">
<li><strong>SLAM回环检测阈值</strong>
   使用Scan Context进行回环检测，描述子为20×60的矩阵。如何设置相似度阈值以平衡检测率和误检率？设计实验验证方案。</li>
</ol>
<p><em>Hint: 考虑场景变化对描述子的影响</em></p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   阈值设置：

   - 初始阈值：0.15×20×60 = 180
   - 动态调整：根据场景复杂度±20%

   实验方案：

   1. 收集100对真实回环和100对非回环
   2. 计算ROC曲线
   3. 选择F1-score最大的阈值
   4. 在线验证并自适应调整
   </details>
<ol start="7">
<li><strong>实时点云检测优化</strong>
   某自动驾驶系统要求在50ms内完成128线激光雷达（约10万点）的目标检测。设计一个满足实时性的检测流程，包括各步骤的时间预算。</li>
</ol>
<p><em>Hint: 考虑并行化和早期剔除策略</em></p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   优化流程：

   1. ROI提取（5ms）：只处理[-30m,30m]×[-15m,15m]
   2. 地面分割（10ms）：GPU并行RANSAC
   3. 体素化（5ms）：0.2m分辨率
   4. 聚类（15ms）：并行DBSCAN
   5. 分类（10ms）：轻量级PointNet
   6. 后处理（5ms）：NMS和跟踪关联

   总计：50ms，满足要求
   </details>
<ol start="8">
<li><strong>点云配准不确定度传播</strong>
   两次激光扫描的测距误差均为σ_r = 2cm，角度误差σ_θ = 0.1°。通过ICP配准后，估计最终位姿的不确定度。考虑100m距离处的目标。</li>
</ol>
<p><em>Hint: 使用误差传播公式和协方差矩阵</em></p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   单点不确定度：

   - 距离方向：σ_r = 2cm
   - 切向：σ_t = r×σ_θ = 100×0.1×π/180 = 17.5cm

   配准后（假设N=1000个匹配点）：

   - 平移不确定度：σ_trans ≈ σ_r/√N = 0.6mm
   - 旋转不确定度：σ_rot ≈ σ_θ/√N = 0.003°

   最终位姿协方差矩阵对角元素：
   [0.6mm², 0.6mm², 0.6mm², 0.003°², 0.003°², 0.003°²]
   </details>
            </article>
            
            <nav class="page-nav"><a href="chapter8.html" class="nav-link prev">← Chapter 8: 点云处理基础算法</a><a href="chapter10.html" class="nav-link next">Chapter 10: 标定技术 →</a></nav>
        </main>
    </div>
</body>
</html>